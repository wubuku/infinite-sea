// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea::ship_battle_aggregate {
    use infinite_sea::player::Player;
    use infinite_sea::roster::Roster;
    use infinite_sea::ship_battle;
    use infinite_sea::ship_battle_initiate_battle_logic;
    use infinite_sea::ship_battle_make_move_logic;
    use infinite_sea::ship_battle_take_loot_logic;
    use infinite_sea_common::coordinates::{Self, Coordinates};
    use infinite_sea_common::experience_table::ExperienceTable;
    use sui::clock::Clock;
    use sui::tx_context;

    friend infinite_sea::skill_process_service;
    friend infinite_sea::roster_service;
    friend infinite_sea::ship_battle_service;

    #[allow(unused_mut_ref)]
    public fun initiate_battle(
        player: &Player,
        initiator: &mut Roster,
        responder: &mut Roster,
        clock: &Clock,
        initiator_coordinates_x: u32,
        initiator_coordinates_y: u32,
        responder_coordinates_x: u32,
        responder_coordinates_y: u32,
        ctx: &mut tx_context::TxContext,
    ): ship_battle::ShipBattle {
        let initiator_coordinates: Coordinates = coordinates::new(
            initiator_coordinates_x,
            initiator_coordinates_y,
        );
        let responder_coordinates: Coordinates = coordinates::new(
            responder_coordinates_x,
            responder_coordinates_y,
        );
        let ship_battle_initiated = ship_battle_initiate_battle_logic::verify(
            player,
            initiator,
            responder,
            clock,
            initiator_coordinates,
            responder_coordinates,
            ctx,
        );
        let ship_battle = ship_battle_initiate_battle_logic::mutate(
            &mut ship_battle_initiated,
            initiator,
            responder,
            ctx,
        );
        ship_battle::set_ship_battle_initiated_id(&mut ship_battle_initiated, ship_battle::id(&ship_battle));
        ship_battle::emit_ship_battle_initiated(ship_battle_initiated);
        ship_battle
    }

    #[allow(unused_mut_ref)]
    public entry fun make_move(
        ship_battle: &mut ship_battle::ShipBattle,
        player: &Player,
        initiator: &mut Roster,
        responder: &mut Roster,
        clock: &Clock,
        attacker_command: u8,
        ctx: &mut tx_context::TxContext,
    ) {
        let ship_battle_move_made = ship_battle_make_move_logic::verify(
            player,
            initiator,
            responder,
            clock,
            attacker_command,
            ship_battle,
            ctx,
        );
        ship_battle_make_move_logic::mutate(
            &mut ship_battle_move_made,
            initiator,
            responder,
            ship_battle,
            ctx,
        );
        ship_battle::update_object_version(ship_battle);
        ship_battle::emit_ship_battle_move_made(ship_battle_move_made);
    }

    public entry fun take_loot(
        ship_battle: &mut ship_battle::ShipBattle,
        player: &mut Player,
        loser_player: &mut Player,
        initiator: &mut Roster,
        responder: &mut Roster,
        experience_table: &ExperienceTable,
        clock: &Clock,
        choice: u8,
        ctx: &mut tx_context::TxContext,
    ) {
        let ship_battle_loot_taken = ship_battle_take_loot_logic::verify(
            player,
            loser_player,
            initiator,
            responder,
            experience_table,
            clock,
            choice,
            ship_battle,
            ctx,
        );
        ship_battle_take_loot_logic::mutate(
            &ship_battle_loot_taken,
            player,
            loser_player,
            initiator,
            responder,
            ship_battle,
            ctx,
        );
        ship_battle::update_object_version(ship_battle);
        ship_battle::emit_ship_battle_loot_taken(ship_battle_loot_taken);
    }

}
