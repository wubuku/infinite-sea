// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module infinite_sea_nft::avatar_aggregate {
    use infinite_sea_nft::avatar;
    use infinite_sea_nft::avatar_burn_logic;
    use infinite_sea_nft::avatar_change::AvatarChange;
    use infinite_sea_nft::avatar_mint_logic;
    use infinite_sea_nft::avatar_update_logic;
    use infinite_sea_nft::avatar_whitelist_mint_logic;
    use infinite_sea_nft::whitelist::Whitelist;
    use std::string::String;
    use sui::tx_context;

    const ENotPublisher: u64 = 50;

    public entry fun mint(
        publisher: &sui::package::Publisher,
        owner: address,
        name: String,
        image_url: String,
        description: String,
        background_color: u32,
        race: u8,
        eyes: u8,
        mouth: u8,
        haircut: u8,
        skin: u8,
        outfit: u8,
        accessories: u8,
        aura: vector<u8>,
        symbols: vector<u8>,
        effects: vector<u8>,
        backgrounds: vector<u8>,
        decorations: vector<u8>,
        badges: vector<u8>,
        ctx: &mut tx_context::TxContext,
    ) {
        assert!(sui::package::from_package<avatar::Avatar>(publisher), ENotPublisher);
        let avatar_minted = avatar_mint_logic::verify(
            owner,
            name,
            image_url,
            description,
            background_color,
            race,
            eyes,
            mouth,
            haircut,
            skin,
            outfit,
            accessories,
            aura,
            symbols,
            effects,
            backgrounds,
            decorations,
            badges,
            ctx,
        );
        let avatar = avatar_mint_logic::mutate(
            &avatar_minted,
            ctx,
        );
        avatar::set_avatar_minted_id(&mut avatar_minted, avatar::id(&avatar));
        avatar::transfer_object(avatar, avatar::avatar_minted_owner(&avatar_minted));
        avatar::emit_avatar_minted(avatar_minted);
    }

    public entry fun update(
        avatar: avatar::Avatar,
        avatar_change: &AvatarChange,
        ctx: &mut tx_context::TxContext,
    ) {
        let avatar_updated = avatar_update_logic::verify(
            avatar_change,
            &mut avatar,
            ctx,
        );
        let updated_avatar = avatar_update_logic::mutate(
            &avatar_updated,
            avatar,
            ctx,
        );
        avatar::update_version_and_transfer_object(updated_avatar, tx_context::sender(ctx));
        avatar::emit_avatar_updated(avatar_updated);
    }

    public entry fun burn(
        avatar: avatar::Avatar,
        ctx: &mut tx_context::TxContext,
    ) {
        let avatar_burned = avatar_burn_logic::verify(
            &avatar,
            ctx,
        );
        let updated_avatar = avatar_burn_logic::mutate(
            &avatar_burned,
            avatar,
            ctx,
        );
        avatar::drop_avatar(updated_avatar);
        avatar::emit_avatar_burned(avatar_burned);
    }

    public entry fun whitelist_mint(
        whitelist: &mut Whitelist,
        ctx: &mut tx_context::TxContext,
    ) {
        let avatar_whitelist_minted = avatar_whitelist_mint_logic::verify(
            whitelist,
            ctx,
        );
        let avatar = avatar_whitelist_mint_logic::mutate(
            &avatar_whitelist_minted,
            whitelist,
            ctx,
        );
        avatar::set_avatar_whitelist_minted_id(&mut avatar_whitelist_minted, avatar::id(&avatar));
        avatar::transfer_object(avatar, avatar::avatar_whitelist_minted_owner(&avatar_whitelist_minted));
        avatar::emit_avatar_whitelist_minted(avatar_whitelist_minted);
    }

}
